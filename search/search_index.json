{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"django-semantic-search","text":"<p>Bringing semantic search to Django. Integrates seamlessly with Django ORM.</p> <p>Django built-in search capabilities are rather limited. Finding a relevant instance of a model relies on the relational database's search capabilities, like SQL <code>LIKE</code> queries. This is not ideal for high-quality search results. This library aims to provide a semantic search capability to Django, allowing for more relevant search results. All this is done in a Django-friendly way, integrating with Django ORM.</p> <p>The library does not aim to provide all the features of search engines, but rather to provide a simple way to integrate Django applications with semantic search capabilities, using existing vector search engines, a.k.a. vector databases, and embedding models.</p>"},{"location":"#installation","title":"Installation","text":"<p>The <code>django-semantic-search</code> library can be installed via your favorite package manager. For example, using <code>pip</code>:</p> <pre><code>pip install django-semantic-search\n</code></pre> <p>The current version is still experimental, and the API may change in the future.</p>"},{"location":"#supported-tools","title":"Supported tools","text":"<p><code>django-semantic-search</code> has to cooperate with other tools to provide semantic search capabilities. You have to choose a vector search engine and an embedding model to use with the library, and configure them in the Django settings.</p>"},{"location":"#vector-search-engines","title":"Vector search engines","text":"<p>The library supports the following vector search engines:</p> <ul> <li>Qdrant</li> </ul> <p>If you would like to contribute support for another vector search engine, feel free to create a pull request.</p>"},{"location":"#embedding-models","title":"Embedding models","text":"<p>Choosing the right embedding model is crucial for the quality of the search results. The current version of the library focuses on bringing the semantic search capabilities to Django, and provides just a single integration with the vector embedding models:</p> <ul> <li>Sentence Transformers</li> </ul> <p>In web-based applications, it makes a lot of sense to choose an external service for the embedding model, as it can be resource-intensive. Please do expect that the library will support more embedding models in the future, and will provide a way to integrate them with Django.</p> <p>Again, if you would like to contribute support for another embedding model, feel free to create a pull request.</p>"},{"location":"#configuration","title":"Configuration","text":"<p>As with any Django application, you need to add the library to the <code>INSTALLED_APPS</code> list in the <code>settings.py</code> file of your project:</p> settings.py<pre><code>INSTALLED_APPS = [\n    ...,  # external apps, such as Django Rest Framework\n    'django_semantic_search',\n    ...,  # your custom apps, using django-semantic-search\n]\n</code></pre> <p>All the library configuration is also done in the <code>settings.py</code> file of the project, via the <code>SEMANTIC_SEARCH</code> dictionary. Here is a full example of the configuration:</p> settings.py<pre><code>SEMANTIC_SEARCH = {\n    # Vector store is a backend that stores the vectors and provides the search functionality.\n    \"vector_store\": {\n        # Either the path to the backend class or the class itself\n        \"backend\": \"django_semantic_search.backends.qdrant.QdrantBackend\",\n        # Configuration is passed directly to the backend class during initialization.\n        \"configuration\": {\n            \"location\": \"http://localhost:6333\",\n        },\n    },\n    # Default embeddings are used to generate the embeddings for the documents if no embeddings are provided.\n    # For the time being, there is no way to provide embeddings for the documents, so the default embeddings\n    # are used for all the documents.\n    \"default_embeddings\": {\n        # Either the path to the embeddings model class or the class itself\n        \"model\": \"django_semantic_search.embeddings.SentenceTransformerModel\",\n        # Configuration is passed directly to the embeddings model class during initialization.\n        \"configuration\": {\n            \"model_name\": \"sentence-transformers/all-MiniLM-L6-v2\",\n        },\n    },\n}\n</code></pre>"},{"location":"#quickstart","title":"Quickstart","text":"<p>If you would like to be guided step-by-step through the installation and configuration process, please refer to the Quickstart guide.</p>"},{"location":"#examples","title":"Examples","text":"<p>If you prefer going straight to the code, you can check the <code>examples</code> folder. In the future it will contain more examples of how to use the library, but for the time being, it contains just a simple Django project with a single app that demonstrates how to use the library.</p>"},{"location":"#simple-django-app","title":"Simple Django App","text":"<p>The <code>examples</code> folder contains a minimal Django <code>simple_django_app</code> project using the <code>django-semantic-search</code> library. It shows how to configure semantic search in a Django project. The application defines a simple model and a document class for it, and demonstrates how to search for instances of the model using the library.</p>"},{"location":"#prerequisites","title":"Prerequisites","text":"<p>By default, the <code>simple_django_app</code> project uses the <code>Qdrant</code> vector search engine and the <code>all-MiniLM-L6-v2</code> Sentence Transformers model. You have to install the <code>django-semantic-search</code> library with the <code>qdrant</code> and <code>sentence-transformers</code> extras to run the project. The dependencies might be installed from the requirements file:</p> <pre><code>pip install -r examples/simple_django_app/requirements.txt\n</code></pre> <p>The default configuration assumes that the Qdrant service is running on <code>localhost:6333</code>. Please refer to the Qdrant documentation on how to set up the service.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>This quickstart guide will help you to get started with the <code>django-semantic-search</code> library. It will guide you through the installation process, the configuration of the vector search engine and the embedding model, and the definition of documents for the selected model.</p> <p>Assuming you already have a Django project set up, let's get started.</p>"},{"location":"quickstart/#1-install-django-semantic-search","title":"1. Install django-semantic-search","text":"<p>The <code>django-semantic-search</code> library can be installed via your favorite package manager. For example, using <code>pip</code>:</p> <pre><code>pip install django-semantic-search\n</code></pre> <p>The default installation does not include any vector search engine or embedding model, so you typically have to install the package with the desired support. For example, to install the package with Qdrant and Sentence Transformers support, you can run:</p> <pre><code>pip install django-semantic-search[qdrant,sentence-transformers]\n</code></pre>"},{"location":"quickstart/#2-modify-the-django-settings","title":"2. Modify the Django settings","text":"<p>Add the library to the <code>INSTALLED_APPS</code> list in the <code>settings.py</code> file of your project:</p> settings.py<pre><code>INSTALLED_APPS = [\n    ...,  # external apps, such as Django Rest Framework\n    'django_semantic_search',\n    ...,  # your custom apps, using django-semantic-search\n]\n</code></pre>"},{"location":"quickstart/#3-choose-the-vector-search-engine-and-the-embedding-model","title":"3. Choose the vector search engine and the embedding model","text":"<p>Do not close the <code>settings.py</code> file yet. You need to configure the vector search engine and the embedding model. Add the <code>SEMANTIC_SEARCH</code> dictionary to the <code>settings.py</code> file of the project, with the desired configuration. Here is an example of the configuration:</p> settings.py<pre><code>SEMANTIC_SEARCH = {\n    # Vector store is a backend that stores the vectors and provides the search functionality.\n    \"vector_store\": {\n        # Either the path to the backend class or the class itself\n        \"backend\": \"django_semantic_search.backends.qdrant.QdrantBackend\",\n        # Configuration is passed directly to the backend class during initialization.\n        \"configuration\": {\n            \"location\": \"http://localhost:6333\",\n        },\n    },\n    # Default embeddings are used to generate the embeddings for the documents if no embeddings are provided.\n    # For the time being, there is no way to provide embeddings for the documents, so the default embeddings\n    # are used for all the documents.\n    \"default_embeddings\": {\n        # Either the path to the embeddings model class or the class itself\n        \"model\": \"django_semantic_search.embeddings.SentenceTransformerModel\",\n        # Configuration is passed directly to the embeddings model class during initialization.\n        \"configuration\": {\n            \"model_name\": \"sentence-transformers/all-MiniLM-L6-v2\",\n        },\n    },\n}\n</code></pre> <p>We defined the <code>Qdrant</code> vector search engine and the <code>all-MiniLM-L6-v2</code> embedding model. You can choose other models from the Sentence Transformers library, for the time being.</p>"},{"location":"quickstart/#4-create-a-model-class-skip-if-you-already-have-one","title":"4. Create a model class (skip if you already have one)","text":"<p>Our example will use a simple model class, <code>Book</code>, with the <code>title</code>, <code>author</code>, and <code>description</code> fields. Here is the model definition:</p> books/models.py<pre><code>from django.db import models\n\nclass Book(models.Model):\n    title = models.CharField(max_length=255)\n    author = models.CharField(max_length=255)\n    description = models.TextField()\n</code></pre> <p>A newly created model means we need to create a migration and apply it to the database:</p> <pre><code>python manage.py makemigrations\npython manage.py migrate\n</code></pre>"},{"location":"quickstart/#5-define-document-class-for-the-selected-model","title":"5. Define document class for the selected model","text":"<p>Once the model is defined, you need to create a document class that inherits from <code>django_semantic_search.Document</code>.</p> <p>Assuming we have a <code>Book</code> model with the <code>title</code>, <code>author</code>, and <code>description</code> fields, here is an example of a document class for the <code>Book</code> model, with the <code>title</code> and <code>description</code> fields defined as searchable. Please do not forget to use the <code>register_document</code> decorator to register the document class with the library.</p> books/documents.py<pre><code>from django_semantic_search import Document, VectorIndex, register_document\nfrom books.models import Book\n\n@register_document\nclass BookDocument(Document):\n    class Meta:\n        model = Book\n        indexes = [\n            VectorIndex(\"title\"),\n            VectorIndex(\"description\"),\n        ]\n</code></pre> <p>Currently, only single fields can be used for the vector index.</p> <p>The decorator <code>register_document</code> takes care of creating the signals for the model, so all the created/updated/deleted instances of the model will be automatically indexed in the vector search engine.</p>"},{"location":"quickstart/#6-create-and-store-the-instances-of-the-model","title":"6. Create and store the instances of the model","text":"<p>From now on, whenever you create or update an instance of the <code>Book</code> model, the instance will be automatically indexed in the vector search engine. Here is an example of creating a new instance of the <code>Book</code> model:</p> books/views.py<pre><code>from books.models import Book\n\ndef create_book(request):\n    book = Book.objects.create(\n        title=\"The Lord of the Rings\",\n        author=\"J.R.R. Tolkien\",\n        description=\"The Lord of the Rings is an epic high-fantasy novel by the English author and scholar J. R. R. Tolkien.\"\n    )\n    return book\n</code></pre> <p>The <code>create_book</code> function creates a new instance of the <code>Book</code> model with the title, author, and description fields filled in. The instance is then returned. Under the hood, a corresponding document is created and indexed in the vector search engine. It ignores the <code>author</code> field, as it is not defined as a searchable field in the <code>BookDocument</code> class.</p>"},{"location":"quickstart/#7-search-for-the-instances-of-the-model","title":"7. Search for the instances of the model","text":"<p>The <code>BookDocument</code> class serves as a bridge between the Django model and the vector search engine. You can use the <code>search</code> method to find the most relevant instances of the model. Here is an example of searching for the instances of the <code>Book</code> model:</p> books/views.py<pre><code>from books.documents import BookDocument\n\nresults = BookDocument.objects.search(title=query)\n</code></pre> <p>We specifically chose the <code>title</code> field to search for the instances of the <code>Book</code> model. The <code>search</code> method returns a queryset of the most relevant instances of the model, based on the search query. Alternatively, you can search for the instances using the <code>description</code> field:</p> books/views.py<pre><code>results = BookDocument.objects.search(description=query)\n</code></pre> <p>Currently, only a single field can be used for the search query, but we plan to extend this functionality in the future.</p> <p>Info</p> <p>This tutorial covers the happy path of using the <code>django-semantic-search</code> library. If you encounter any issues or have any questions, feel free to create an issue in the project's repository. Please make sure to check the list of Frequency Asked Questions before creating a new issue.</p>"},{"location":"usage/","title":"Usage","text":"<p>This section focuses on specific usage examples of the <code>django-semantic-search</code> library. If you are looking for a step-by-step introduction, please refer to the Quickstart guide.</p>"},{"location":"usage/#configuration","title":"Configuration","text":"<p>As with any Django application, you need to add the library to the <code>INSTALLED_APPS</code> list in the <code>settings.py</code> file of your project:</p> settings.py<pre><code>INSTALLED_APPS = [\n    ...,  # external apps, such as Django Rest Framework\n    'django_semantic_search',\n    ...,  # your custom apps, using django-semantic-search\n]\n</code></pre> <p>All the library configuration is also done in the <code>settings.py</code> file of the project, via the <code>SEMANTIC_SEARCH</code> dictionary. Here is a full example of the configuration:</p> settings.py<pre><code>SEMANTIC_SEARCH = {\n    # Vector store is a backend that stores the vectors and provides the search functionality.\n    \"vector_store\": {\n        # Either the path to the backend class or the class itself\n        \"backend\": \"django_semantic_search.backends.qdrant.QdrantBackend\",\n        # Configuration is passed directly to the backend class during initialization.\n        \"configuration\": {\n            \"location\": \"http://localhost:6333\",\n        },\n    },\n    # Default embeddings are used to generate the embeddings for the documents if no embeddings are provided.\n    # For the time being, there is no way to provide embeddings for the documents, so the default embeddings\n    # are used for all the documents.\n    \"default_embeddings\": {\n        # Either the path to the embeddings model class or the class itself\n        \"model\": \"django_semantic_search.embeddings.SentenceTransformerModel\",\n        # Configuration is passed directly to the embeddings model class during initialization.\n        \"configuration\": {\n            \"model_name\": \"sentence-transformers/all-MiniLM-L6-v2\",\n        },\n    },\n}\n</code></pre>"},{"location":"usage/#frequently-asked-questions","title":"Frequently Asked Questions","text":"<p>This section describes some common questions and answers related to the <code>django-semantic-search</code> library.</p>"},{"location":"usage/#how-to-define-which-fields-are-searchable","title":"How to define which fields are searchable?","text":"<p>To define the search fields for a model, you need to create a document class that inherits from <code>django_semantic_search.Document</code>. There is no strict requirement for the document class to be put in a specific package, but it is recommended to put it in the <code>documents.py</code> file in the app package.</p> <p>Assuming, we have a <code>Book</code> model with the <code>title</code>, <code>author</code>, and <code>description</code> fields:</p> books/models.py<pre><code>from django.db import models\n\nclass Book(models.Model):\n    title = models.CharField(max_length=255)\n    author = models.CharField(max_length=255)\n    description = models.TextField()\n</code></pre> <p>Here is an example of a document class for the <code>Book</code> model, with the <code>title</code> and <code>description</code> fields defined as searchable:</p> books/documents.py<pre><code>from django_semantic_search import Document, VectorIndex\nfrom books.models import Book\n\nclass BookDocument(Document):\n    class Meta:\n        model = Book\n        indexes = [\n            VectorIndex(\"title\"),\n            VectorIndex(\"description\"),\n        ]\n</code></pre> <p>Currently, the default embedding model is used for all the fields.</p>"},{"location":"usage/#how-to-search-for-documents","title":"How to search for documents?","text":"<p>To search for documents, you can use the <code>search</code> method of the document class. The method returns a Django queryset with the search results.</p> <p>Here is an example of searching for books with the title containing the word \"Django\":</p> books/views.py<pre><code>from books.documents import BookDocument\n\ndef search_books(request):\n    query = \"Django\"\n    books = BookDocument.objects.search(title=query)\n    return render(request, \"books/search_results.html\", {\"books\": books})\n</code></pre> <p>Using the named arguments in the <code>search</code> method allows you to search for documents with specific fields.</p>"},{"location":"usage/#how-to-index-the-existing-data","title":"How to index the existing data?","text":"<p>If you are adding the <code>django-semantic-search</code> library to an existing project, you may want to index the existing instances of the models. To do this, you can use the <code>index</code> method of the document class.</p> <p>Here is an example of indexing all the existing instances of the <code>Book</code> model:</p> index_models.py<pre><code>from books.models import Book\nfrom books.documents import BookDocument\n\ndef index_books(request):\n    all_books = Book.objects.all()\n    BookDocument.objects.index(all_books)\n    return HttpResponse(\"Books indexed successfully.\")\n</code></pre> <p>Warning</p> <p>Indexing all the instances of the model can be resource-intensive, as each instance of the model has to be converted to the vector representation. It is recommended to run the indexing process in a background task or a separate management command.</p>"},{"location":"api/backends/","title":"Backends","text":"<p>Backends are external tools supposed to provide the functionality of semantic search. The library does not assume any specific backend, but it provides a way to integrate with them. The following backends are supported:</p>"},{"location":"api/backends/#qdrant","title":"Qdrant","text":"<p>Qdrant is a high-performance vector search engine written in Rust.</p> <pre><code>pip install django-semantic-search[qdrant]\n</code></pre>"},{"location":"api/backends/#django_semantic_search.backends.qdrant.QdrantBackend","title":"<code>django_semantic_search.backends.qdrant.QdrantBackend</code>","text":"<p>               Bases: <code>BaseVectorSearchBackend</code></p> <p>Backend that integrates with Qdrant vector database.</p> <p>It handles the configuration of separate collections per each model we want to enable search for. Users rarely interact with this backend directly, as backend is usually configured via Django settings.</p> <p>Requirements:</p> <pre><code>pip install django-semantic-search[qdrant]\n</code></pre> <p>Usage:</p> settings.py<pre><code>SEMANTIC_SEARCH = {\n    \"vector_store\": {\n        \"backend\": \"django_semantic_search.backends.qdrant.QdrantBackend\",\n        \"configuration\": {\n            \"host\": \"http://localhost:6333\",\n        },\n    },\n    ...\n}\n</code></pre> Source code in <code>src/django_semantic_search/backends/qdrant.py</code> <pre><code>class QdrantBackend(BaseVectorSearchBackend):\n    \"\"\"\n    Backend that integrates with Qdrant vector database.\n\n    It handles the configuration of separate collections per each model we want to enable search for. Users rarely\n    interact with this backend directly, as backend is usually configured via Django settings.\n\n    **Requirements**:\n\n    ```bash\n    pip install django-semantic-search[qdrant]\n    ```\n\n    **Usage**:\n\n    ```python title=\"settings.py\"\n    SEMANTIC_SEARCH = {\n        \"vector_store\": {\n            \"backend\": \"django_semantic_search.backends.qdrant.QdrantBackend\",\n            \"configuration\": {\n                \"host\": \"http://localhost:6333\",\n            },\n        },\n        ...\n    }\n    ```\n    \"\"\"\n\n    from qdrant_client import models\n\n    DISTANCE_MAPPING = {\n        Distance.COSINE: models.Distance.COSINE,\n        Distance.EUCLIDEAN: models.Distance.EUCLID,\n        Distance.DOT_PRODUCT: models.Distance.DOT,\n    }\n\n    def __init__(self, index_configuration: IndexConfiguration, *args, **kwargs):\n        from qdrant_client import QdrantClient\n\n        self.client = QdrantClient(*args, **kwargs)\n        super().__init__(index_configuration)\n\n    def configure(self):\n        from qdrant_client import models\n\n        try:\n            collection_info = self.client.get_collection(  # noqa\n                collection_name=self.index_configuration.namespace\n            )\n            # TODO: validate if all the vectors are present and with correct types\n        except Exception:\n            logger.warning(\n                f\"Collection {self.index_configuration.namespace} does not exist. Creating a new one.\"\n            )\n            self.client.create_collection(\n                collection_name=self.index_configuration.namespace,\n                vectors_config={\n                    vector_name: models.VectorParams(\n                        size=vector_config.size,\n                        distance=self.DISTANCE_MAPPING.get(vector_config.distance),\n                    )\n                    for vector_name, vector_config in self.index_configuration.vectors.items()\n                },\n            )\n            self.client.create_payload_index(\n                collection_name=self.index_configuration.namespace,\n                field_name=self.index_configuration.id_field,\n                field_schema=models.PayloadSchemaType.KEYWORD,\n            )\n\n    def search(\n        self, vector_name: str, query: List[float], limit: int = 10\n    ) -&gt; List[DocumentID]:\n        results = self.client.query_points(\n            collection_name=self.index_configuration.namespace,\n            query=query,\n            using=vector_name,\n            limit=limit,\n            with_vectors=False,\n            with_payload=True,\n        )\n        return [\n            result.payload.get(self.index_configuration.id_field)\n            for result in results.points\n        ]\n\n    def save(self, document: Document):\n        from qdrant_client import models\n\n        vectors = document.vectors()\n        payload = {\n            self.index_configuration.id_field: document.id,\n            **document.metadata(),\n        }\n        self.client.upsert(\n            collection_name=self.index_configuration.namespace,\n            points=[\n                models.PointStruct(\n                    id=uuid.uuid4().hex,\n                    vector=vectors,\n                    payload=payload,\n                )\n            ],\n        )\n\n    def delete(self, document_id: DocumentID):\n        from qdrant_client import models\n\n        self.client.delete(\n            collection_name=self.index_configuration.namespace,\n            points_selector=models.Filter(\n                must=[\n                    models.FieldCondition(\n                        key=self.index_configuration.id_field,\n                        match=models.MatchValue(\n                            value=document_id,\n                        ),\n                    )\n                ]\n            ),\n        )\n</code></pre>"},{"location":"api/documents/","title":"API Reference","text":"<p><code>django-semantic-search</code> was designed to mimic some of the patterns used in popular Django libraries, such as <code>django-import-export</code> to reduce the learning curve for new users.</p> <p>The base concept of the library is a <code>Document</code> subclass that represents a single searchable entity. The library provides a way to define a document class for a selected model. The document class is responsible for converting the model instances into the vector representation and storing them in the vector search engine, as well as for performing the search queries.</p>"},{"location":"api/documents/#documents","title":"Documents","text":""},{"location":"api/documents/#django_semantic_search.Document","title":"<code>django_semantic_search.Document</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Base class for all the documents. There is a one-to-one mapping between the document subclass and the model class, to configure how a specific model instances should be converted to a document.</p> <p>Usage:</p> products/models.py<pre><code>from django.db import models\n\nclass Product(models.Model):\n    name = models.CharField(max_length=255)\n    description = models.TextField()\n</code></pre> products/documents.py<pre><code>from django_semantic_search import Document, VectorIndex\nfrom django_semantic_search.decorators import register_document\n\n@register_document\nclass ProductDocument(Document):\n    class Meta:\n        model = Product\n        indexes = [\n            VectorIndex(\"name\"),\n            VectorIndex(\"description\"),\n        ]\n</code></pre> <p><code>django-semantic-search</code> will automatically handle all the configuration in the backend. The <code>register_document</code> decorator will register the model signals to update the documents in the vector store when the model is updated or deleted. As a user you don't have to manually call the <code>save</code> or <code>delete</code> methods on the document instances.</p> <p>Search example:</p> products/views.py<pre><code>from django.http import JsonResponse\nfrom products.documents import ProductDocument\n\ndef my_view(request):\n    query = \"this is a query\"\n    results = ProductDocument.objects.find(name=query)\n    return JsonResponse(\n        {\n            \"results\": list(name_results.values())\n        }\n    )\n</code></pre> <p>The <code>find</code> method on the <code>objects</code> attribute of the document class will return the queryset of the model instances that are similar to the query. The search is performed using the selected vector index passed as a keyword argument to the <code>find</code> method. In our case, we are searching for the query in the <code>name</code> field of the <code>Product</code> model. If we want to search in the <code>description</code> field, we would call <code>ProductDocument.objects.find(description=query)</code>.</p> Source code in <code>src/django_semantic_search/documents.py</code> <pre><code>class Document(abc.ABC, Generic[T]):\n    \"\"\"\n    Base class for all the documents. There is a one-to-one mapping between the document subclass and the model class,\n    to configure how a specific model instances should be converted to a document.\n\n    **Usage**:\n\n    ```python title=\"products/models.py\"\n    from django.db import models\n\n    class Product(models.Model):\n        name = models.CharField(max_length=255)\n        description = models.TextField()\n\n    ```\n\n    ```python title=\"products/documents.py\"\n    from django_semantic_search import Document, VectorIndex\n    from django_semantic_search.decorators import register_document\n\n    @register_document\n    class ProductDocument(Document):\n        class Meta:\n            model = Product\n            indexes = [\n                VectorIndex(\"name\"),\n                VectorIndex(\"description\"),\n            ]\n    ```\n\n    `django-semantic-search` will automatically handle all the configuration in the backend. The `register_document`\n    decorator will register the model signals to update the documents in the vector store when the model is updated\n    or deleted. As a user you don't have to manually call the `save` or `delete` methods on the document instances.\n\n    **Search example:**\n\n    ```python title=\"products/views.py\"\n    from django.http import JsonResponse\n    from products.documents import ProductDocument\n\n    def my_view(request):\n        query = \"this is a query\"\n        results = ProductDocument.objects.find(name=query)\n        return JsonResponse(\n            {\n                \"results\": list(name_results.values())\n            }\n        )\n    ```\n\n    The `find` method on the `objects` attribute of the document class will return the queryset of the model instances\n    that are similar to the query. The search is performed using the selected vector index passed as a keyword argument\n    to the `find` method. In our case, we are searching for the query in the `name` field of the `Product` model. If we\n    want to search in the `description` field, we would call `ProductDocument.objects.find(description=query)`.\n    \"\"\"\n\n    # Important:\n    # The following descriptors have to be defined in the specific order, as they depend on each other\n    # and the order of the descriptors is the order in which they are executed.\n    meta = MetaManager()\n    index_configuration = IndexConfigurationManager()\n    backend = BackendManager()\n    objects: DocumentManager = DocumentManagerDescriptor[T]()\n\n    def __init__(self, instance: T):\n        self._instance = instance\n\n    def save(self) -&gt; None:\n        \"\"\"\n        Save the document in the vector store.\n        \"\"\"\n        if not self._instance.pk:\n            raise ValueError(\n                \"The model instance has to be saved before creating a document.\"\n            )\n        self.backend.save(self)\n\n    def delete(self) -&gt; None:\n        \"\"\"\n        Delete the document from the vector store.\n        \"\"\"\n        self.backend.delete(self.id)\n\n    @property\n    def id(self) -&gt; DocumentID:\n        if not self._instance.pk:\n            raise ValueError(\n                \"The model instance has to be saved before accessing the ID.\"\n            )\n        return self._instance.pk\n\n    def vectors(self) -&gt; Dict[str, Vector]:\n        \"\"\"\n        Return the vectors for the document.\n        :return: dictionary of the vectors.\n        \"\"\"\n        return {\n            index.index_name: index.get_model_embedding(self._instance)\n            for index in self.meta.indexes\n        }\n\n    def metadata(self) -&gt; Dict[str, MetadataValue]:\n        \"\"\"\n        Return the metadata for the document.\n        :return: dictionary of the metadata.\n        \"\"\"\n        include_fields = getattr(\n            self.meta, \"include_fields\", Document.Meta.include_fields\n        )\n        if \"*\" in include_fields:\n            include_fields = [field.name for field in self._instance._meta.fields]\n        return {field: getattr(self._instance, field) for field in include_fields}\n\n    class Meta:\n        # The model this document is associated with\n        model: Type[models.Model] = None\n        # Namespace for the documents in the vector store, defaults to the model name\n        namespace: Optional[str] = None\n        # List of vector indexes created out of the model fields\n        indexes: Iterable[VectorIndex] = []\n        # Model fields that should be included in the metadata\n        include_fields: List[str] = [\"*\"]\n        # Flag to disable signals on the model, so the documents are not updated on model changes\n        disable_signals: bool = False\n</code></pre>"},{"location":"api/embeddings/","title":"Embedding models","text":"<p>An embedding model is a tool that converts text data into a vector representation. The quality of the embedding model is crucial for the quality of the search results. Currently, <code>django-semantic-search</code> supports just a single integration with the vector embedding models:</p>"},{"location":"api/embeddings/#sentence-transformers","title":"Sentence Transformers","text":"<p>The Sentence Transformers library provides a way to convert text data into a vector representation. There are over 5,000 pre-trained models available, and you can choose the one that fits your needs the best.</p> <pre><code>pip install django-semantic-search[sentence-transformers]\n</code></pre> <p>One of the available models is <code>all-MiniLM-L6-v2</code>, which is a lightweight model that provides a good balance between the quality of the search results and the resource consumption.</p>"},{"location":"api/embeddings/#django_semantic_search.embeddings.SentenceTransformerModel","title":"<code>django_semantic_search.embeddings.SentenceTransformerModel</code>","text":"<p>               Bases: <code>BaseEmbeddingModel</code>, <code>TextEmbeddingMixin</code></p> <p>Sentence-transformers model for embedding text.</p> <p>It is a wrapper around the sentence-transformers library. Users would rarely need to use this class directly, but rather specify it in the Django settings.</p> <p>Requirements:</p> <pre><code>pip install django-semantic-search[sentence-transformers]\n</code></pre> <p>Usage:</p> settings.py<pre><code>SEMANTIC_SEARCH = {\n    \"default_embeddings\": {\n        \"model\": \"django_semantic_search.embeddings.SentenceTransformerModel\",\n        \"configuration\": {\n            \"model_name\": \"sentence-transformers/all-MiniLM-L6-v2\",\n        },\n    },\n    ...\n}\n</code></pre> Source code in <code>src/django_semantic_search/embeddings/sentence_transformers.py</code> <pre><code>class SentenceTransformerModel(BaseEmbeddingModel, TextEmbeddingMixin):\n    \"\"\"\n    Sentence-transformers model for embedding text.\n\n    It is a wrapper around the sentence-transformers library. Users would rarely need to use this class directly, but\n    rather specify it in the Django settings.\n\n    **Requirements:**\n\n    ```shell\n    pip install django-semantic-search[sentence-transformers]\n    ```\n\n    **Usage:**\n\n    ```python title=\"settings.py\"\n    SEMANTIC_SEARCH = {\n        \"default_embeddings\": {\n            \"model\": \"django_semantic_search.embeddings.SentenceTransformerModel\",\n            \"configuration\": {\n                \"model_name\": \"sentence-transformers/all-MiniLM-L6-v2\",\n            },\n        },\n        ...\n    }\n    ```\n    \"\"\"\n\n    def __init__(\n        self,\n        model_name: str,\n        document_prompt: Optional[str] = None,\n        query_prompt: Optional[str] = None,\n    ):\n        \"\"\"\n        Initialize the sentence-transformers _model.\n        :param model_name: name of the model to use.\n        \"\"\"\n        from sentence_transformers import SentenceTransformer\n\n        self._model = SentenceTransformer(model_name)\n        self._document_prompt = document_prompt\n        self._query_prompt = query_prompt\n\n    def vector_size(self) -&gt; int:\n        \"\"\"\n        Return the size of the individual embedding.\n        :return: size of the embedding.\n        \"\"\"\n        return self._model.get_sentence_embedding_dimension()\n\n    def embed_document(self, document: str) -&gt; Vector:\n        \"\"\"\n        Embed a document into a vector.\n        :param document: document to embed.\n        :return: document embedding.\n        \"\"\"\n        return self._model.encode(document, prompt=self._document_prompt).tolist()\n\n    def embed_query(self, query: str) -&gt; Vector:\n        \"\"\"\n        Embed a query into a vector.\n        :param query: query to embed.\n        :return: query embedding.\n        \"\"\"\n        return self._model.encode(query, prompt=self._query_prompt).tolist()\n</code></pre>"}]}